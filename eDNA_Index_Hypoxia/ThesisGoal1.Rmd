---
title: "Thesis Goal 1"
author: "Eleanor (Ella) Crotty"
header-includes:
  \usepackage{fvextra}
  \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
output:
  pdf_document:
    toc: TRUE
urlcolor: blue
---

```{r Package Imports, message = F, warning = F}
# Warnings and startup messages suppressed
library(tidyverse)
library(patchwork)
library(scales)
library(ggrepel)
library(readxl)
library(here)
library(mgcv)
library(gratia)
```

Goal 1: Compare copepod eDNA index, a measure of relative abundance using eDNA detections, to dissolved oxygen data in order to assess whether hypoxia decreases copepod abundance in OCNMS.

# Goals

-   Plot eDNA index over time and oxygen
-   Make scatterplots of eDNA index vs oxygen
-   Do a GAM of eDNA index vs oxygen
-   Compare eDNA to hypoxic thresholds

# Import data

```{r}
envData <- read_csv(here("PMEL-Data", "EnvironmentalDataset1_copy.csv")) %>% 
  filter(year != 2023) %>%  # Ignoring 2023 due to gaps for now
  mutate(year = as.factor(year)) %>% 
  relocate(year, .after = date)
allReads <- read_csv(here("PMEL-Data", "FishPlusCOI_Reads_copy.csv")) %>% 
  mutate(year = year(Date_local)) %>% 
  relocate(year, .after = Date_local) 
yrReads <- allReads %>% 
  filter(year != 2023) %>%   # Ignoring 2023 due to gaps for now
  mutate(year = as.factor(year))
copepodNames <- read_csv(here("PMEL-Data", "OCNMS_Copepods_Krill_copy.csv"))
eDNAxEnvDataSat <- read_csv(here("PMEL-Data", "eDNAxEnvDataSat_copy.csv"))
copepodFiltered <- read_csv(here("CopepodDetectionsFiltered.csv"))
copepodFull <- read_csv(here("CopepodDetectionsFull.csv"))
```

# Calculate eDNA index

```{r}
copepods <- unique(copepodFull$Species)
copepodReads <- allReads %>% 
  filter(Species %in% copepods) # Just in case
  
index1dummy <- allReads %>% # Quick proportions
  dplyr::group_by(SampleId) %>% 
  mutate(Tot = sum(nReads),
      	Row.sums = nReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(Tot, Row.sums), .after = SampleId)
```

```{r}
# First, combine PCR replicates and average
PCR_reps_combine <- function(df) {
  # print(head(df))
  
  # Separate out Sample_Name into three informational columns
  df_out <- df %>% 
    separate(Sample_Name, 
             into=c("E_no", "Cruise1", "PCR_Rep"), 
             remove=F, 
             fill = "right") %>% # sep is a regular expression which is annoying, but the default recognizes any non-alphanumeric characters so the default works here
    mutate(.)
  
  # Define which columns to group by
  id_cols1 <- colnames(df_out) # Pull out column names
  id_cols1 <- id_cols1[! id_cols1 %in% c("X", "SampleId","Sample_Name", "PCR_Rep", "pctMatch", "JV_Sample_Name", "Technical_Replicate", "nReads", "Barcode.y")] # Remove SampleId and Sample_Name, as well as other things that differ by PCR replicate
  print(id_cols1)
  
  df_out <- df_out %>% 
    group_by_at(id_cols1) %>% 
    # dplyr::mutate(SampleId = dplyr::first(SampleId)) %>% # Just ignoring sampleid for now and using E-no as unique
    summarize(nReads = mean(nReads)) %>% 
    relocate(nReads, .after = PI)
    
  df_out
}

allReads_PCRcomb <- PCR_reps_combine(allReads) # Spot check E1325 was correct
```

```{r}
# Second, combine by species

id_cols <- colnames(allReads_PCRcomb) # Pull out column names
id_cols <- id_cols[! id_cols %in% c("X", "ESV", "sequence", "nReads")] # Remove ESV + nreads because those are different within species

allReads_species <- allReads_PCRcomb %>% 
  group_by_at(id_cols) %>% # group_by_at can take a vector
  summarize(TotalnReads = sum(nReads)) %>% # Removed , avgpctMatch = mean(pctMatch) because I had to remove pctMatch to combine PCR replicates. Sum nReads results in taking the sum of all ESVs within a species
  relocate(TotalnReads, .after = PI)

write_csv(allReads_species, here("eDNA_Index_Hypoxia", "Data", "CopepodReads_Species.csv")) # Gonna want this later

all_index1 <- allReads_species %>%
  dplyr::group_by(E_no) %>% # Group by E-number, beacuse sampleID had to be removed in the PCR replicate combination step
  mutate(Tot = sum(TotalnReads),
      	Row.sums = TotalnReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(TotalnReads, Tot, Row.sums), .after = E_no) # Move it somewhere I can see the damn thing

all_eDNA_index <- all_index1 %>% 
  dplyr::group_by(Species) %>%
  mutate(Row.sums = case_when(Row.sums == "NaN" ~ 0, 
                                      .default = Row.sums)) %>% # Make 0/0 = 0 and not NaN
  mutate(Colmax = max(Row.sums), Normalized.reads = Row.sums / Colmax) %>%  #transforms raw number of reads to eDNA index. Creates same divide by 0 error, so:
  mutate(Normalized.reads = case_when(Normalized.reads == "NaN" ~ 0, 
                                      .default = Normalized.reads)) %>% # Make 0/0 = 0 and not NaN
  relocate(c(Colmax, Normalized.reads), .after = Row.sums)  # Move it somewhere I can see the damn thing

# Filter to only copepods
copepod_eDNA_index <- all_eDNA_index %>% 
  filter(Species %in% copepods) %>% 
  rename(eDNA_index = `Normalized.reads`) # to make parsing this easier

write_csv(copepod_eDNA_index, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNA_index.csv")) # Gonna want this later
```

# Combine eDNA index with environmental data

```{r}
# envData = EnvironmentalDataset1
# Based on eDNAxpO2.Rmd from summer project
# copepod_eDNA_index is still essentially a version of allReads so I can use the same code I did with allReads_Species

EnvRd <- envData %>% 
  mutate(DateMatch = round_date(date, unit = "10 minutes")) # Round to the nearest 10 minutes
DetectRd <- copepod_eDNA_index %>% 
  mutate(DateMatch = round_date(Date_UTC, unit = "10 minutes"), Date_local_hr = round_date(Date_local, unit = "hour")) # Spot check - looks good. 

eDNAindxEnvData <- left_join(DetectRd, EnvRd, by = join_by(DateMatch)) %>% 
  relocate(date, .after = Date_UTC) %>% 
  relocate(year.x, .after = Date_UTC) %>% 
  relocate(year.y, .after = Date_UTC) %>% 
  filter(year.x != 2023) %>% 
  filter()

investigate <- eDNAindxEnvData %>% select(Species, DateMatch, Date_UTC, Date_local_hr, source, temperature, DO, E_no, Rosette_position, Amplicon)

system("say Data Join Complete")

# Export the joined data
write_csv(eDNAindxEnvData, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData.csv"))
```

```{r}
# Make a version without the copepods that are only detected in 2023 because those plots are unhelpful
eDNAindxEnvData_clean <- eDNAindxEnvData %>% 
  filter(Colmax > 0)
  
write_csv(eDNAindxEnvData_clean, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData_clean.csv"))
```

# Re-calculate eDNA index for 2021-2022 only

```{r}
index1dummyYr <- yrReads %>% # Quick proportions
  dplyr::group_by(SampleId) %>% 
  mutate(Tot = sum(nReads),
      	Row.sums = nReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(Tot, Row.sums), .after = SampleId)

yrReads_PCRcomb <- PCR_reps_combine(yrReads) # Spot check E1325 was correct

# Second, combine by species

id_cols <- colnames(yrReads_PCRcomb) # Pull out column names
id_cols <- id_cols[! id_cols %in% c("X", "ESV", "sequence", "nReads")] # Remove ESV + nreads because those are different within species

allReads_speciesYr <- yrReads_PCRcomb %>% 
  group_by_at(id_cols) %>% # group_by_at can take a vector
  summarize(TotalnReads = sum(nReads)) %>% # Removed , avgpctMatch = mean(pctMatch) because I had to remove pctMatch to combine PCR replicates. Sum nReads results in taking the sum of all ESVs within a species
  relocate(TotalnReads, .after = PI)

write_csv(allReads_speciesYr, here("eDNA_Index_Hypoxia", "Data", "CopepodReads_Species_no23.csv")) # Gonna want this later

all_index1Yr <- allReads_speciesYr %>%
  dplyr::group_by(E_no) %>% # Group by E-number, beacuse sampleID had to be removed in the PCR replicate combination step
  mutate(Tot = sum(TotalnReads),
      	Row.sums = TotalnReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(TotalnReads, Tot, Row.sums), .after = E_no) # Move it somewhere I can see the damn thing

yr_eDNA_index <- all_index1Yr %>% 
  dplyr::group_by(Species) %>%
  mutate(Row.sums = case_when(Row.sums == "NaN" ~ 0, 
                                      .default = Row.sums)) %>% # Make 0/0 = 0 and not NaN
  mutate(Colmax = max(Row.sums), Normalized.reads = Row.sums / Colmax) %>%  #transforms raw number of reads to eDNA index. Creates same divide by 0 error, so:
  mutate(Normalized.reads = case_when(Normalized.reads == "NaN" ~ 0, 
                                      .default = Normalized.reads)) %>% # Make 0/0 = 0 and not NaN
  relocate(c(Colmax, Normalized.reads), .after = Row.sums)  # Move it somewhere I can see the damn thing

# Filter to only copepods
copepod_eDNA_indexYr <- yr_eDNA_index %>% 
  filter(Species %in% copepods) %>% 
  rename(eDNA_index = `Normalized.reads`) # to make parsing this easier

write_csv(copepod_eDNA_indexYr, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNA_index_no23.csv")) # Gonna want this later

# envData = EnvironmentalDataset1
# Based on eDNAxpO2.Rmd from summer project
# copepod_eDNA_index is still essentially a version of allReads so I can use the same code I did with allReads_Species

DetectRdYr <- copepod_eDNA_indexYr %>% 
  mutate(DateMatch = round_date(Date_UTC, unit = "10 minutes"), Date_local_hr = round_date(Date_local, unit = "hour")) # Spot check - looks good. 

eDNAindxEnvDataYr <- left_join(DetectRdYr, EnvRd, by = join_by(DateMatch)) %>% 
  relocate(date, .after = Date_UTC) %>% 
  relocate(year.x, .after = Date_UTC) %>% 
  relocate(year.y, .after = Date_UTC) %>% 
  filter(year.x != 2023) %>% 
  filter()

investigateYr <- eDNAindxEnvDataYr %>% select(Species, DateMatch, Date_UTC, Date_local_hr, source, temperature, DO, E_no, Rosette_position, Amplicon)

system("say Data Join Without 2023 Complete")

# Export the joined data
write_csv(eDNAindxEnvDataYr, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData_no23.csv"))

# Make a version without the copepods that are only detected in 2023 because those plots are unhelpful
eDNAindxEnvData_cleanYr <- eDNAindxEnvDataYr %>% 
  filter(Colmax > 0)
  
write_csv(eDNAindxEnvData_cleanYr, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData_clean_no23.csv"))
```

# Plot eDNA index over time and oxygen

```{r}
# Explore eDNA index by species
ggplot(copepod_eDNA_index, aes(x = Date_local, y = eDNA_index, color = Species)) +
  geom_point(show.legend = F, size = 1) +
  facet_wrap(facets = vars(year(Date_local)), scales = "free_x") +
  geom_line(show.legend = F) +
  theme_bw()

ggplot(eDNAindxEnvData, aes(x = Date_local, y = eDNA_index, color = Species)) +
  geom_point(show.legend = F, size = 1) +
  facet_wrap(facets = vars(year(Date_local)), scales = "free_x") +
  geom_line(show.legend = F) +
  theme_bw()
# Seems legit! 

ggplot(eDNAindxEnvDataYr, aes(x = Date_local, y = eDNA_index, color = Species)) +
  geom_point(show.legend = F, size = 1) +
  facet_wrap(facets = vars(year(Date_local)), scales = "free_x") +
  geom_line(show.legend = F) +
  theme_bw()
```

```{r}
source(here("eDNA_Index_Hypoxia", "eDNA_EnvGraphFunction.R"))


eDNAGraph(eDNAindxEnvData_clean, 
          envCond = "DO", 
          envCondName = "Oxygen", 
          filepath = here("eDNA_Index_Hypoxia", "Plots", "eDNAxDO"),
          ylab = "Dissolved Oxygen (mg/L)", 
          widthpx = 3000, # make it longer
          threshold = F,
          thresholdLvl = 2
          )

eDNAGraph(eDNAindxEnvData_cleanYr, # ignoring 2023
          envCond = "DO", 
          envCondName = "Oxygen", 
          filepath = here("eDNA_Index_Hypoxia", "Plots", "eDNAxDO_no23"),
          ylab = "Dissolved Oxygen (mg/L)", 
          widthpx = 3000, # make it longer
          threshold = F,
          thresholdLvl = 2
          )

system("say Graphs complete")
```

## Scatterplot eDNA vs hypoxic threshold

```{r}
eDNAindxEnvData_cleanYr <- eDNAindxEnvData_cleanYr %>% 
  mutate(Hypoxic = case_when(DO < 2 ~ T, .default = F))

ggplot(eDNAindxEnvData_cleanYr, aes(x = Date_local, y = DO, color = Hypoxic)) +
  theme_bw() +
  geom_point()
```

```{r}
ggplot(eDNAindxEnvData_cleanYr, aes(x = eDNA_index)) +
  geom_histogram(fill = "cornflowerblue") +
  theme_bw() +
  facet_wrap(facets = vars(Hypoxic), ncol = 1)
```

\newpage

# GAM of eDNA index vs oxygen

```{r}
dfsplit <- split(eDNAindxEnvData_cleanYr, eDNAindxEnvData_cleanYr$Species) # Split by species

# Because the distribution of eDNA index is restricted to 0-1, Zack suggested using a beta regression flavor of GAM. A linear predictor controls the mean, and it estimates variance
# copied from documentation example, family = betar(link="logit")
# Picking a link function: can be  "logit", "probit", "cloglog" and "cauchit". The default is logit, I'm going with that for now.
# This will convert all the exactly zero values to 0.0000000000001ish, will that be a problem since we have so many 0s? They're theoretically replaced with highly improbable values. The documentation suggests manually resetting the 0s in a way that reflects the sampling setup. 

# Documentation says: 
# These models are useful for proportions data which can not be modelled as binomial. Note the assumption that data are in (0,1), despite the fact that for some parameter values 0 and 1 are perfectly legitimate observations. The restriction is needed to keep the log likelihood bounded for all parameter values. Any data exactly at 0 or 1 are reset to be just above 0 or just below 1 using the eps argument (in fact any observation <eps is reset to eps and any observation >1-eps is reset to 1-eps). Note the effect of this resetting. If mu phi>1 mu phi>1 then impossible 0s are replaced with highly improbable eps values. If the inequality is reversed then 0s with infinite probability density are replaced with eps values having high finite probability density. The equivalent condition for 1s is (1-mu)phi>1(1-mu)phi>1. Clearly all types of resetting are somewhat unsatisfactory, and care is needed if data contain 0s or 1s (often it makes sense to manually reset the 0s and 1s in a manner that somehow reflects the sampling setup). 

for (i in 1:length(dfsplit)) { # For each species: 
    species <- dfsplit[[i]]$Species[1] # Species name 
    title <- paste(species, sep = " ", "eDNA Index vs Dissolved Oxygen") # Plot title, changed for eDNA
    print(title)
    
    # Plot the GAM + save it
    # I don't think I can make geom_smooth do a beta regression -_-
    print(ggplot(dfsplit[[i]], aes(x = DO, y = eDNA_index)) + # plot this species
      geom_point(color = "orange2", alpha = 0.7) +
      geom_smooth(method = 'gam', se = F, color = "cornflowerblue") + # visualize GAM
      geom_vline(xintercept = 0.66, linetype = 2, color = "red") + # most copepods die
      geom_vline(xintercept = 0.9, linetype = 2, color = "orange") + # ~50% of copepods die
      geom_vline(xintercept = 2.66, linetype = 2, color = "forestgreen") + # many copepods experience sublethal effects (e.g. less egg production)
      ggtitle(title) +
      theme_bw())
    ggsave(filename = paste(species, sep = "_", "eDNA_DO_GAM_Prelim.png"), path = here("eDNA_Index_Hypoxia", "Plots", "GAM_Initial"), width = 2500, height = 2000, units = "px")
    
    # Make the GAM as an object and print some quality metrics
    ind_DO_GAM <- gam(eDNA_index ~ s(DO), bs = "cr", data = dfsplit[[i]], family = betar(link="logit"))
    print(summary(ind_DO_GAM))
    
    print("GAM quality")
    print(paste("AIC: ", sep = "", AIC(ind_DO_GAM))) # quality metric
    print(summary(ind_DO_GAM)$sp.criterion)
    print(gam.check(ind_DO_GAM, k.rep = 1000)) # Bunch of graphs and also text output, which is used to check how the GAM is doing
    
      ## how to interpret
      # edf = effective degrees of freedom
      # GCV = generalized cross validation, an estimate of the mean square prediction error. comparing between models, lower GCV is better
      # Lower AIC is also better
      # Higher R^2 is better
    
  # graph predicted GAM
    gamdat <- c()
    DO <- seq(0.001, 8, 0.1)
    vals <- as.data.frame(DO)
    pds <- predict.gam(ind_DO_GAM, newdata = vals)
    vals2 <- data.frame(vals, mu = pds)
    gamdatdf <- rbind(gamdat, vals2)
    
    print(ggplot(data = gamdatdf, aes(x = DO, y = mu)) + # plot this species
            geom_point(color = "cornflowerblue", alpha = 0.7) +
            xlab("DO") +
            ylab("eDNA Index (Predicted in Blue)") +
            geom_point(data = dfsplit[[i]], aes(x = DO, y = eDNA_index),
                       color = "orange2", alpha = 0.7
                       ) +
            geom_vline(xintercept = 0.66, linetype = 2, color = "red") + # most copepods die
            geom_vline(xintercept = 0.9, linetype = 2, color = "orange") + # ~50% of copepods die
            geom_vline(xintercept = 2.66, linetype = 2, color = "forestgreen") + # many copepods
            ggtitle(title) +
            theme_bw())
    
    ggsave(filename = paste(species, sep = "_", "eDNA_DO_GAM.png"), path = here("eDNA_Index_Hypoxia", "Plots", "GAM_Pred"), width = 2500, height = 2000, units = "px")
}

# I think I'm still having some issues w.r.t. the 2023 elimination issue

system("say G A M complete")
```

# Binomial Regression

**Binomial Regression Assumptions**

1. Independent observations - *Check!*
2. No multicollinearity: Continuous independent variables should not be correlated with each other - *NOT MET - shouldn't do a DO x Temp x Presence model*
3. Binomial dependent variable, with two **mutually exclusive** values - *Check!*
4. Continuous independent variable - *Check!*
5. Linearity between the binomial and continuous variables - this is checked with a logit transformation - *See below, this varies by species*
6. Sufficient obeservations - the source I found recommends > 15 - *Eeeeeeeh, only with a few*
7. No outliers - *One outlier, which appears to be part of a real heatwave - I have not filtered it out yet*

## Filter out outliers 

```{r, eval = T}
fullData <- eDNAindxEnvData_cleanYr
fullData_noOutlier <- eDNAindxEnvData_cleanYr %>% 
  filter(temperature < 11)
```

```{r}
eDNAxEnvData_box <- eDNAindxEnvData_cleanYr %>% 
  mutate(Present = case_when(TotalnReads == 0 ~ F, .default = T)) %>% 
  mutate(year = as.factor(year.x))

eDNAxEnvData_box <- eDNAxEnvData_box %>% 
  filter(!is.na(DO & !is.na(Present) & !is.na(year))) %>% 
  filter(!(Species %in% c("Calanus pacificus", "Clausocalanus parapergens", "Clausocalanus pergens", "Diacyclops incolotaenia", "Lucicutia flavicornis", "Metridia lucens"))) # For some goddamn reason there's a species or two that REFUSES to box tidwell

joinSpeciesList <- split(eDNAxEnvData_box, eDNAxEnvData_box$Species) # Split by species

library(car) # Has a function for the Box-Tidwell procedure
?boxTidwell

# Single test
boxTidwell(Present ~ DO, data = joinSpeciesList[[1]]) # other.x = any factors not to be transformed. i had to make year into a factor to make it accept this, not sure what it's doing.
# for some reason this works without other.x. go fucking figure.

# Loop to test all for linearity with DO
#for (i in 1:length(joinSpeciesList)) {
#  print(paste(names(joinSpeciesList)[i], sep = " ", "Presence vs Oxygen"))
#  print(boxTidwell(Present ~ DO, data = joinSpeciesList[[i]]))
#}

# this thing is Not Working for most of them. coming back to it later.
```

## Calculate regression

```{r}
oxmodels <- lapply(joinSpeciesList, glm, formula = Present ~ SatPct, family = "binomial") # Make the model for each species
lapply(oxmodels, summary) # Print the summary of each model
```

## Looped Binomial Regression

```{r}
# Make a function that'll do the binomial regression AND put the results in a dataframe

SpeciesMod <- c()
InterceptP <- c()
SlopeP <- c()
SampleSizes <- c()

#modtest <- glm(Detect50Split[[1]], formula = Present ~ SatPct, family = "binomial")
#modsum <- summary(modtest)
#Coefficients: modsum$coeffifients[1 = intercept/2 = slope, 4]

for (i in 1:length(joinSpeciesList)) {
  SpName <- names(joinSpeciesList)[i]
  SpeciesMod <- c(SpeciesMod, SpName)
  
  df <- joinSpeciesList[[i]]
  
  SampleSize <- sum(df$Present)
  SampleSizes <- c(SampleSizes, SampleSize)
  
  # lapply(joinSpeciesList, glm, formula = Present ~ SatPct, family = "binomial")
  mod <- glm(df, formula = Present ~ DO, family = "binomial")
  modsum <- summary(mod)
  
  Intercept <- round(modsum$coefficients[1,4], digits = 5)
  Slope <- round(modsum$coefficients[2,4], digits = 5)
  InterceptP <- c(InterceptP, Intercept)
  SlopeP <- c(SlopeP, Slope)
}

BinomialRegressionResults <- data.frame(Species = SpeciesMod, InterceptP, SlopeP, n = SampleSizes)

SignificantSlopes <- BinomialRegressionResults %>% filter(SlopeP < 0.05)
SignificantIntercepts <- BinomialRegressionResults %>% filter(InterceptP < 0.05)

SigSp <- SignificantSlopes$Species
SigSpDf <- eDNAindxEnvData_cleanYr %>% 
  filter(Species %in% SigSp)

system("say Binomial Regression Models Computed")
```

## Graph binom regresion
```{r}
library(ggpmisc)

# Add title
# Add better axis labels
for (i in 1:length(joinSpeciesList)) {
  df <- joinSpeciesList[[i]] %>% mutate(PresentBin = case_when(Present == T ~ 1, Present == F ~ 0)) %>%  # Select one species and mutate to 0/1 so that the regression will run
    filter(temperature < 11) # Filter out the outlier
  
  species <- as.character(joinSpeciesList[[i]][1,7]) # Extract species name for title + export filename

  ggplot(df, aes(x = DO, y = PresentBin, color = PresentBin)) +
    geom_point(size = 4) +
    scale_color_gradient(high = "dodgerblue3", low = "orange2", guide = "legend", na.value = "black") + # Color to match presence/absence graphs
    geom_smooth(method = "glm", method.args = list(family = "binomial"), se = F) +
    # Print the binomial regression
    stat_poly_eq(use_label(c("R2")), size = 6, label.y = 0.75, label.x = 60) + # Print R^2 and p-value from the model
    theme_bw() +
    theme(text = element_text(size = 20)) +
    labs(title = species, x = "Oxygen Saturation (%)", y = "Species Present?")
  
    ggsave(filename = here("eDNA_Index_Hypoxia", "Plots",
                           "Binomial_Regressions", 
                           paste(species, sep = ".", "png")), # Save graph
           width = 2300, 
           height = 2000, 
           units = "px")
}

system("say Binomial Regression Graphs Complete!")
```

# Heatmap of DO x Temp x eDNA

```{r}
for (i in 1:length(dfsplit)) { # For each species: 
    species <- dfsplit[[i]]$Species[1] # Species name 
    title <- paste(species, sep = " ", "eDNA Index vs Dissolved Oxygen & Temperature") # Plot title
    print(title)
    
# Plot + save
    
    print( # plot this species
      ggplot(dfsplit[[i]], aes(x = temperature, 
                                    y = DO, 
                                    size = eDNA_index, color = eDNA_index)) +
        scale_color_continuous(type = "viridis") +
        geom_point(alpha = 0.5) +
        ggtitle(title) +
        geom_hline(yintercept = 0.66, linetype = 2, color = "red") + # most copepods die
        geom_hline(yintercept = 0.9, linetype = 2, color = "orange") + # ~50% of copepods die
        geom_hline(yintercept = 2.66, linetype = 2, color = "forestgreen") + # many copepods experience sublethal effects (e.g. less egg production)
        theme_bw()
    )
      
    ggsave(filename = paste(species, sep = "_", "eDNA_DO_Temp_ScatterSize.png"), 
           path = here("eDNA_Index_Hypoxia", "Plots", "DO_Temp_Scatter"), 
           width = 2500, height = 2000, units = "px")
}
```
```{r}
for (i in 1:length(dfsplit)) { # For each species: 
    species <- dfsplit[[i]]$Species[1] # Species name 
    title <- paste(species, sep = " ", "eDNA Index vs Dissolved Oxygen & Temperature") # Plot title
    print(title)
    
# Plot + save
    
    print( # plot this species
      ggplot(dfsplit[[i]], aes(x = temperature, 
                                    y = DO, 
                                    color = eDNA_index)) +
        scale_color_continuous(type = "viridis") +
        geom_point(alpha = 0.7) +
        ggtitle(title) +
        geom_hline(yintercept = 0.66, linetype = 2, color = "red") + # most copepods die
        geom_hline(yintercept = 0.9, linetype = 2, color = "orange") + # ~50% of copepods die
        geom_hline(yintercept = 2.66, linetype = 2, color = "forestgreen") + # many copepods experience sublethal effects (e.g. less egg production)
        theme_bw()
    )
      
    ggsave(filename = paste(species, sep = "_", "eDNA_DO_Temp_Scatter.png"), 
           path = here("eDNA_Index_Hypoxia", "Plots", "DO_Temp_Scatter"), 
           width = 2500, height = 2000, units = "px")
}
```

```{r}
for (i in 1:length(dfsplit)) { # For each species: 
    species <- dfsplit[[i]]$Species[1] # Species name 
    title <- paste(species, sep = " ", "eDNA Index vs Dissolved Oxygen & Temperature") # Plot title
    print(title)
    
# Plot + save
    
    print( # plot this species
      ggplot(dfsplit[[i]], aes(x = temperature, 
                                    y = DO, 
                                    color = eDNA_index)) +
        scale_color_continuous(type = "viridis") +
        geom_point(alpha = 0.5, shape = 15, size = 3) +
        ggtitle(title) +
        geom_hline(yintercept = 0.66, linetype = 2, color = "red") + # most copepods die
        geom_hline(yintercept = 0.9, linetype = 2, color = "orange") + # ~50% of copepods die
        geom_hline(yintercept = 2.66, linetype = 2, color = "forestgreen") + # many copepods experience sublethal effects (e.g. less egg production)
        theme_bw()
    )
      
    ggsave(filename = paste(species, sep = "_", "eDNA_DO_Temp_Heat.png"), 
           path = here("eDNA_Index_Hypoxia", "Plots", "DO_Temp_Heat"), 
           width = 2500, height = 2000, units = "px")
}
```

```{r}
system("say Script complete")
```
