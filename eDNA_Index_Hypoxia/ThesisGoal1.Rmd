---
title: "Thesis Goal 1"
author: "Eleanor (Ella) Crotty"
header-includes:
  \usepackage{fvextra}
  \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
output:
  pdf_document:
    toc: TRUE
urlcolor: blue
---

```{r Package Imports, message = F, warning = F}
# Warnings and startup messages suppressed
library(tidyverse)
library(patchwork)
library(scales)
library(ggrepel)
library(readxl)
library(here)
library(mgcv)
library(gratia)
```

Goal 1: Compare copepod eDNA index, a measure of relative abundance using eDNA detections, to dissolved oxygen data in order to assess whether hypoxia decreases copepod abundance in OCNMS. 

# Goals

- Plot eDNA index over time and oxygen
- Make scatterplots of eDNA index vs oxygen
- Do a GAM of eDNA index vs oxygen
- Compare eDNA to hypoxic thresholds

# Import data
```{r}
envData <- read_csv(here("PMEL-Data", "EnvironmentalDataset1_copy.csv")) %>% 
  filter(year != 2023) %>%  # Ignoring 2023 due to gaps for now
  mutate(year = as.factor(year)) %>% 
  relocate(year, .after = date)
allReads <- read_csv(here("PMEL-Data", "FishPlusCOI_Reads_copy.csv")) %>% 
  mutate(year = year(Date_local)) %>% 
  relocate(year, .after = Date_local) 
yrReads <- allReads %>% 
  filter(year != 2023) %>%   # Ignoring 2023 due to gaps for now
  mutate(year = as.factor(year))
copepodNames <- read_csv(here("PMEL-Data", "OCNMS_Copepods_Krill_copy.csv"))
eDNAxEnvDataSat <- read_csv(here("PMEL-Data", "eDNAxEnvDataSat_copy.csv"))
copepodFiltered <- read_csv(here("CopepodDetectionsFiltered.csv"))
copepodFull <- read_csv(here("CopepodDetectionsFull.csv"))
```

# Calculate eDNA index
```{r}
copepods <- unique(copepodFull$Species)
copepodReads <- allReads %>% 
  filter(Species %in% copepods) # Just in case
  
index1dummy <- allReads %>% # Quick proportions
  dplyr::group_by(SampleId) %>% 
  mutate(Tot = sum(nReads),
      	Row.sums = nReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(Tot, Row.sums), .after = SampleId)
```

```{r}
# First, combine PCR replicates and average
PCR_reps_combine <- function(df) {
  # print(head(df))
  
  # Separate out Sample_Name into three informational columns
  df_out <- df %>% 
    separate(Sample_Name, 
             into=c("E_no", "Cruise1", "PCR_Rep"), 
             remove=F, 
             fill = "right") %>% # sep is a regular expression which is annoying, but the default recognizes any non-alphanumeric characters so the default works here
    mutate(.)
  
  # Define which columns to group by
  id_cols1 <- colnames(df_out) # Pull out column names
  id_cols1 <- id_cols1[! id_cols1 %in% c("X", "SampleId","Sample_Name", "PCR_Rep", "pctMatch", "JV_Sample_Name", "Technical_Replicate", "nReads", "Barcode.y")] # Remove SampleId and Sample_Name, as well as other things that differ by PCR replicate
  print(id_cols1)
  
  df_out <- df_out %>% 
    group_by_at(id_cols1) %>% 
    # dplyr::mutate(SampleId = dplyr::first(SampleId)) %>% # Just ignoring sampleid for now and using E-no as unique
    summarize(nReads = mean(nReads)) %>% 
    relocate(nReads, .after = PI)
    
  df_out
}

allReads_PCRcomb <- PCR_reps_combine(allReads) # Spot check E1325 was correct
```

```{r}
# Second, combine by species

id_cols <- colnames(allReads_PCRcomb) # Pull out column names
id_cols <- id_cols[! id_cols %in% c("X", "ESV", "sequence", "nReads")] # Remove ESV + nreads because those are different within species

allReads_species <- allReads_PCRcomb %>% 
  group_by_at(id_cols) %>% # group_by_at can take a vector
  summarize(TotalnReads = sum(nReads)) %>% # Removed , avgpctMatch = mean(pctMatch) because I had to remove pctMatch to combine PCR replicates. Sum nReads results in taking the sum of all ESVs within a species
  relocate(TotalnReads, .after = PI)

write_csv(allReads_species, here("eDNA_Index_Hypoxia", "Data", "CopepodReads_Species.csv")) # Gonna want this later

all_index1 <- allReads_species %>%
  dplyr::group_by(E_no) %>% # Group by E-number, beacuse sampleID had to be removed in the PCR replicate combination step
  mutate(Tot = sum(TotalnReads),
      	Row.sums = TotalnReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(TotalnReads, Tot, Row.sums), .after = E_no) # Move it somewhere I can see the damn thing

all_eDNA_index <- all_index1 %>% 
  dplyr::group_by(Species) %>%
  mutate(Row.sums = case_when(Row.sums == "NaN" ~ 0, 
                                      .default = Row.sums)) %>% # Make 0/0 = 0 and not NaN
  mutate(Colmax = max(Row.sums), Normalized.reads = Row.sums / Colmax) %>%  #transforms raw number of reads to eDNA index. Creates same divide by 0 error, so:
  mutate(Normalized.reads = case_when(Normalized.reads == "NaN" ~ 0, 
                                      .default = Normalized.reads)) %>% # Make 0/0 = 0 and not NaN
  relocate(c(Colmax, Normalized.reads), .after = Row.sums)  # Move it somewhere I can see the damn thing

# Filter to only copepods
copepod_eDNA_index <- all_eDNA_index %>% 
  filter(Species %in% copepods) %>% 
  rename(eDNA_index = `Normalized.reads`) # to make parsing this easier

write_csv(copepod_eDNA_index, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNA_index.csv")) # Gonna want this later
```
# Combine eDNA index with environmental data
```{r}
# envData = EnvironmentalDataset1
# Based on eDNAxpO2.Rmd from summer project
# copepod_eDNA_index is still essentially a version of allReads so I can use the same code I did with allReads_Species

EnvRd <- envData %>% 
  mutate(DateMatch = round_date(date, unit = "10 minutes")) # Round to the nearest 10 minutes
DetectRd <- copepod_eDNA_index %>% 
  mutate(DateMatch = round_date(Date_UTC, unit = "10 minutes"), Date_local_hr = round_date(Date_local, unit = "hour")) # Spot check - looks good. 

eDNAindxEnvData <- left_join(DetectRd, EnvRd, by = join_by(DateMatch)) %>% 
  relocate(date, .after = Date_UTC) %>% 
  relocate(year.x, .after = Date_UTC) %>% 
  relocate(year.y, .after = Date_UTC) %>% 
  filter(year.x != 2023) %>% 
  filter()

investigate <- eDNAindxEnvData %>% select(Species, DateMatch, Date_UTC, Date_local_hr, source, temperature, DO, E_no, Rosette_position, Amplicon)

system("say Data Join Complete")

# Export the joined data
write_csv(eDNAindxEnvData, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData.csv"))
```

```{r}
# Make a version without the copepods that are only detected in 2023 because those plots are unhelpful
eDNAindxEnvData_clean <- eDNAindxEnvData %>% 
  filter(Colmax > 0)
  
write_csv(eDNAindxEnvData_clean, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData_clean.csv"))
```

# Re-calculate eDNA index for 2021-2022 only

```{r}
index1dummyYr <- yrReads %>% # Quick proportions
  dplyr::group_by(SampleId) %>% 
  mutate(Tot = sum(nReads),
      	Row.sums = nReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(Tot, Row.sums), .after = SampleId)

yrReads_PCRcomb <- PCR_reps_combine(yrReads) # Spot check E1325 was correct

# Second, combine by species

id_cols <- colnames(yrReads_PCRcomb) # Pull out column names
id_cols <- id_cols[! id_cols %in% c("X", "ESV", "sequence", "nReads")] # Remove ESV + nreads because those are different within species

allReads_speciesYr <- yrReads_PCRcomb %>% 
  group_by_at(id_cols) %>% # group_by_at can take a vector
  summarize(TotalnReads = sum(nReads)) %>% # Removed , avgpctMatch = mean(pctMatch) because I had to remove pctMatch to combine PCR replicates. Sum nReads results in taking the sum of all ESVs within a species
  relocate(TotalnReads, .after = PI)

write_csv(allReads_speciesYr, here("eDNA_Index_Hypoxia", "Data", "CopepodReads_Species_no23.csv")) # Gonna want this later

all_index1Yr <- allReads_speciesYr %>%
  dplyr::group_by(E_no) %>% # Group by E-number, beacuse sampleID had to be removed in the PCR replicate combination step
  mutate(Tot = sum(TotalnReads),
      	Row.sums = TotalnReads / Tot) %>% # calculate proportions - 0 reads/0 total = NaN, need to replace with 0 to make max() work
  relocate(c(TotalnReads, Tot, Row.sums), .after = E_no) # Move it somewhere I can see the damn thing

yr_eDNA_index <- all_index1Yr %>% 
  dplyr::group_by(Species) %>%
  mutate(Row.sums = case_when(Row.sums == "NaN" ~ 0, 
                                      .default = Row.sums)) %>% # Make 0/0 = 0 and not NaN
  mutate(Colmax = max(Row.sums), Normalized.reads = Row.sums / Colmax) %>%  #transforms raw number of reads to eDNA index. Creates same divide by 0 error, so:
  mutate(Normalized.reads = case_when(Normalized.reads == "NaN" ~ 0, 
                                      .default = Normalized.reads)) %>% # Make 0/0 = 0 and not NaN
  relocate(c(Colmax, Normalized.reads), .after = Row.sums)  # Move it somewhere I can see the damn thing

# Filter to only copepods
copepod_eDNA_indexYr <- yr_eDNA_index %>% 
  filter(Species %in% copepods) %>% 
  rename(eDNA_index = `Normalized.reads`) # to make parsing this easier

write_csv(copepod_eDNA_indexYr, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNA_index_no23.csv")) # Gonna want this later

# envData = EnvironmentalDataset1
# Based on eDNAxpO2.Rmd from summer project
# copepod_eDNA_index is still essentially a version of allReads so I can use the same code I did with allReads_Species

DetectRdYr <- copepod_eDNA_indexYr %>% 
  mutate(DateMatch = round_date(Date_UTC, unit = "10 minutes"), Date_local_hr = round_date(Date_local, unit = "hour")) # Spot check - looks good. 

eDNAindxEnvDataYr <- left_join(DetectRdYr, EnvRd, by = join_by(DateMatch)) %>% 
  relocate(date, .after = Date_UTC) %>% 
  relocate(year.x, .after = Date_UTC) %>% 
  relocate(year.y, .after = Date_UTC) %>% 
  filter(year.x != 2023) %>% 
  filter()

investigateYr <- eDNAindxEnvDataYr %>% select(Species, DateMatch, Date_UTC, Date_local_hr, source, temperature, DO, E_no, Rosette_position, Amplicon)

system("say Data Join Without 2023 Complete")

# Export the joined data
write_csv(eDNAindxEnvDataYr, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData_no23.csv"))

# Make a version without the copepods that are only detected in 2023 because those plots are unhelpful
eDNAindxEnvData_cleanYr <- eDNAindxEnvDataYr %>% 
  filter(Colmax > 0)
  
write_csv(eDNAindxEnvData_cleanYr, here("eDNA_Index_Hypoxia", "Data", "Copepod_eDNAindxEnvData_clean_no23.csv"))
```


# Plot eDNA index over time and oxygen

```{r}
# Explore eDNA index by species
ggplot(copepod_eDNA_index, aes(x = Date_local, y = eDNA_index, color = Species)) +
  geom_point(show.legend = F, size = 1) +
  facet_wrap(facets = vars(year(Date_local)), scales = "free_x") +
  geom_line(show.legend = F) +
  theme_bw()

ggplot(eDNAindxEnvData, aes(x = Date_local, y = eDNA_index, color = Species)) +
  geom_point(show.legend = F, size = 1) +
  facet_wrap(facets = vars(year(Date_local)), scales = "free_x") +
  geom_line(show.legend = F) +
  theme_bw()
# Seems legit! 

ggplot(eDNAindxEnvDataYr, aes(x = Date_local, y = eDNA_index, color = Species)) +
  geom_point(show.legend = F, size = 1) +
  facet_wrap(facets = vars(year(Date_local)), scales = "free_x") +
  geom_line(show.legend = F) +
  theme_bw()
```


```{r}
source(here("eDNA_Index_Hypoxia", "eDNA_EnvGraphFunction.R"))


eDNAGraph(eDNAindxEnvData_clean, 
          envCond = "DO", 
          envCondName = "Oxygen", 
          filepath = here("eDNA_Index_Hypoxia", "Plots", "eDNAxDO"),
          ylab = "Dissolved Oxygen (mg/L)", 
          widthpx = 3000, # make it longer
          threshold = F,
          thresholdLvl = 2
          )

eDNAGraph(eDNAindxEnvData_cleanYr, # ignoring 2023
          envCond = "DO", 
          envCondName = "Oxygen", 
          filepath = here("eDNA_Index_Hypoxia", "Plots", "eDNAxDO_no23"),
          ylab = "Dissolved Oxygen (mg/L)", 
          widthpx = 3000, # make it longer
          threshold = F,
          thresholdLvl = 2
          )

system("say Graphs complete")
```


## Scatterplot eDNA vs hypoxic threshold
```{r}
eDNAindxEnvData_cleanYr <- eDNAindxEnvData_cleanYr %>% 
  mutate(Hypoxic = case_when(DO < 2 ~ T, .default = F))

ggplot(eDNAindxEnvData_cleanYr, aes(x = Date_local, y = DO, color = Hypoxic)) +
  theme_bw() +
  geom_point()
```

```{r}
ggplot(eDNAindxEnvData_cleanYr, aes(x = eDNA_index)) +
  geom_histogram(fill = "cornflowerblue") +
  theme_bw() +
  facet_wrap(facets = vars(Hypoxic), ncol = 1)
```

# GAM of eDNA index vs oxygen

```{r}
dfsplit <- split(eDNAindxEnvData_cleanYr, eDNAindxEnvData_cleanYr$Species) # Split by species

for (i in 1:length(dfsplit)) { # For each species: 
    species <- dfsplit[[i]]$Species[1] # Species name 
    print(species) 
    title <- paste(species, sep = " ", "eDNA Index vs Dissolved Oxygen") # Plot title, changed for eDNA
    print(title)
    print(ggplot(dfsplit[[i]], aes(x = DO, y = eDNA_index)) + # plot this species
      geom_point(color = "orange2", alpha = 0.7) +
      geom_smooth(method = 'gam', se = F, color = "cornflowerblue") + # visualize GAM
      ggtitle(title) +
      theme_bw())
    ggsave(filename = paste(species, sep = "_", "eDNA_DO_GAM.png"), path = here("eDNA_Index_Hypoxia", "Plots", "GAM_Initial"), width = 2500, height = 2000, units = "px")
}

# I think I'm still having some issues w.r.t. the 2023 elimination issue
```

```{r}
# combine this with previous chunk so the graphs and quality are paired
for (i in 1:length(dfsplit)) { # For each species: 
    species <- dfsplit[[i]]$Species[1] # Species name for title and export png name
    title <- paste(species, sep = " ", "eDNA Index vs Dissolved Oxygen") # Plot title, changed for eDNA
    print(title)
    
    ind_DO_GAM <- gam(eDNA_index ~ s(DO), bs = "cr", data = dfsplit[[i]])
    print(summary(ind_DO_GAM))
    
    print("GAM quality")
    print(paste("AIC: ", sep = "", AIC(ind_DO_GAM))) # quality metric
    print(summary(ind_DO_GAM)$sp.criterion)
    print(gam.check(ind_DO_GAM, k.rep = 1000)) # Bunch of graphs and also text output, which is used to check how the GAM is doing
}
# edf = effective degrees of freedom
# GCV = generalized cross validation, an estimate of the mean square prediction error. comparing between models, lower GCV is better
# Lower AIC is also better
# Higher R^2 is better

system("say G A M complete")
```


```{r}
system("say Script complete")
```

